AWSTemplateFormatVersion: '2010-09-09'
Description: "AgentCore Runtime"

Parameters:
  OpenAIKey:
    Type: String
    Description: OpenAI API Key

  OpenAIModelId:
    Type: String
    Description: OpenAI model id
    Default: 'gpt-4o-2024-08-06'
  
  TavilyAPIKey:
    Type: String
    Description: Tavily API Key

  GitHubURL:
    Type: String
    Description: Github URL of the project
    Default: https://github.com/awslabs/amazon-bedrock-agentcore-samples.git

  AgentDirectory:
    Type: String
    Description: Agent directory with Dockerfile of agent
    Default: web_search_openai_agents

  CognitoStackName:
    Type: String
    Description: Name of the Cognito CloudFormation stack to import values from
    
Resources:
  AgentCoreRuntimeExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: AssumeRolePolicy
            Effect: Allow
            Principal:
              Service: bedrock-agentcore.amazonaws.com
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                'aws:SourceAccount': !Ref AWS::AccountId
              ArnLike:
                'aws:SourceArn': !Sub 'arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:*'
      Policies:
        - PolicyName: AgentCoreRuntimeExecutionPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: ECRImageAccess
                Effect: Allow
                Action:
                  - ecr:BatchGetImage
                  - ecr:GetDownloadUrlForLayer
                Resource:
                  - !Sub 'arn:aws:ecr:${AWS::Region}:${AWS::AccountId}:repository/*'
              - Effect: Allow
                Action:
                  - logs:DescribeLogStreams
                  - logs:CreateLogGroup
                Resource:
                  - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/bedrock-agentcore/runtimes/*'
              - Effect: Allow
                Action:
                  - logs:DescribeLogGroups
                Resource:
                  - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:*'
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/bedrock-agentcore/runtimes/*:log-stream:*'
              - Sid: ECRTokenAccess
                Effect: Allow
                Action:
                  - ecr:GetAuthorizationToken
                Resource: '*'
              - Effect: Allow
                Action:
                  - xray:PutTraceSegments
                  - xray:PutTelemetryRecords
                  - xray:GetSamplingRules
                  - xray:GetSamplingTargets
                Resource: '*'
              - Effect: Allow
                Resource: '*'
                Action: cloudwatch:PutMetricData
                Condition:
                  StringEquals:
                    'cloudwatch:namespace': 'bedrock-agentcore'
              - Sid: BedrockModelAccess
                Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:InvokeModelWithResponseStream
                Resource:
                  - 'arn:aws:bedrock:*::foundation-model/*'
                  - !Sub 'arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:*'
              - Sid: SSMParameterAccess
                Effect: Allow
                Action:
                  - ssm:GetParameter
                  - ssm:GetParameters
                Resource:
                  - !Sub 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/*'
              - Sid: Oauth2Token
                Effect: Allow
                Action:
                  - bedrock-agentcore:GetResourceOauth2Token
                  # TODO: Scope down
                Resource:
                  - '*'
              - Sid: SecretsManager
                Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                  # TODO: Scope down
                Resource:
                  - '*'
              - Sid: MemoryAccess
                Effect: Allow
                Action:
                  - bedrock-agentcore:ListMemories
                  - bedrock-agentcore:ListMemoryRecords
                  - bedrock-agentcore:RetrieveMemoryRecords
                  - bedrock-agentcore:GetMemory
                  - bedrock-agentcore:GetMemoryRecord
                  - bedrock-agentcore:BatchCreateMemoryRecords
                  - bedrock-agentcore:BatchDeleteMemoryRecords
                  - bedrock-agentcore:BatchUpdateMemoryRecords
                  - bedrock-agentcore:ListActors
                  - bedrock-agentcore:ListEvents
                  - bedrock-agentcore:CreateEvent
                  - bedrock-agentcore:GetEvent
                Resource:
                  - !GetAtt AgentMemory.MemoryArn
                  - !Sub '${AgentMemory.MemoryArn}/*'
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-Runtime-Role'

  # ECR Repository for Agent Docker Images
  AgentECRRepository:
    Type: AWS::ECR::Repository
    DeletionPolicy: Delete
    Properties:
      ImageScanningConfiguration:
        ScanOnPush: true
      LifecyclePolicy:
        LifecyclePolicyText: |
          {
            "rules": [
              {
                "rulePriority": 1,
                "description": "Keep last 10 images",
                "selection": {
                  "tagStatus": "any",
                  "countType": "imageCountMoreThan",
                  "countNumber": 10
                },
                "action": {
                  "type": "expire"
                }
              }
            ]
          }
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-Agent-ECR-Repository'

  # CodeBuild Service Role for Docker Image Build
  CodeBuildServiceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: codebuild.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: CodeBuildLogsPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - "*"
        - PolicyName: ECRAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ecr:BatchCheckLayerAvailability
                  - ecr:GetDownloadUrlForLayer
                  - ecr:BatchGetImage
                  - ecr:GetAuthorizationToken
                Resource: '*'
              - Effect: Allow
                Action:
                  - ecr:InitiateLayerUpload
                  - ecr:UploadLayerPart
                  - ecr:CompleteLayerUpload
                  - ecr:PutImage
                Resource: !GetAtt AgentECRRepository.Arn
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-CodeBuild-Role'

  # CodeBuild Project for Agent Docker Image
  AgentDockerBuildProject:
    Type: AWS::CodeBuild::Project
    Properties:
      Description: 'Build and push agent Docker image to ECR'
      ServiceRole: !GetAtt CodeBuildServiceRole.Arn
      Artifacts:
        Type: NO_ARTIFACTS
      Environment:
        Type: ARM_CONTAINER
        ComputeType: BUILD_GENERAL1_LARGE
        Image: aws/codebuild/amazonlinux2-aarch64-standard:3.0
        PrivilegedMode: true
        EnvironmentVariables:
          - Name: ECR_REPOSITORY_URI
            Value: !Sub '${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${AgentECRRepository}'
          - Name: ECR_REPOSITORY_NAME
            Value: !Ref AgentECRRepository
          - Name: AWS_DEFAULT_REGION
            Value: !Ref AWS::Region
          - Name: AWS_ACCOUNT_ID
            Value: !Ref AWS::AccountId
          - Name: AGENT_DIRECTORY
            Value: !Ref AgentDirectory
      Source:
        Type: GITHUB
        Location: !Ref GitHubURL
        GitCloneDepth: 1
        BuildSpec: |
          version: 0.2
          phases:
            pre_build:
              commands:
                - echo "Checking current directory and contents..."
                - pwd
                - ls -la
                - echo "Navigating to agent directory..."
                - cd 02-use-cases/A2A-multi-agent-incident-response/
                - cd ${AGENT_DIRECTORY}
                - echo "Contents of agent directory:"
                - ls -la
                - echo "Checking for Dockerfile..."
                - cat Dockerfile || echo "Dockerfile not found"
                - echo "Generating unique image tag..."
                - export IMAGE_TAG="build-${CODEBUILD_BUILD_NUMBER}"
                - echo "Image will be tagged as ${IMAGE_TAG}"
            build:
              commands:
                - echo "Starting parallel Docker build and ECR authentication..."
                - |
                  docker build -t bedrock-agentcore-arm64 . &
                  BUILD_PID=$!
                  aws ecr get-login-password --region $AWS_DEFAULT_REGION | \
                  docker login --username AWS --password-stdin $ECR_REPOSITORY_URI &
                  AUTH_PID=$!
                  echo "Waiting for Docker build to complete..."
                  wait $BUILD_PID
                  if [ $? -ne 0 ]; then
                    echo "Docker build failed"
                    exit 1
                  fi
                  echo "Waiting for ECR authentication to complete..."
                  wait $AUTH_PID
                  if [ $? -ne 0 ]; then
                    echo "ECR authentication failed"
                    exit 1
                  fi
                  echo "Both build and auth completed successfully"
                - echo "Tagging image with unique tag ${IMAGE_TAG}..."
                - docker tag bedrock-agentcore-arm64:latest $ECR_REPOSITORY_URI:${IMAGE_TAG}
            post_build:
              commands:
                - echo "Pushing ARM64 image to ECR with unique tag ${IMAGE_TAG}..."
                - docker push $ECR_REPOSITORY_URI:${IMAGE_TAG}
                - echo "Build completed at $(date)"
                - echo "Image tag pushed - ${IMAGE_TAG}"
      TimeoutInMinutes: 30
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-Agent-Docker-Build'

  # Lambda Execution Role for ECR Image Notification
  ECRImageNotificationLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: ECRAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ecr:DescribeImages
                  - ecr:ListImages
                Resource: !GetAtt AgentECRRepository.Arn
        - PolicyName: BedrockAgentCoreAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock-agentcore:ListAgentRuntimes
                  - bedrock-agentcore:ListAgentRuntimeEndpoints
                  - bedrock-agentcore:ListAgentRuntimeVersions
                  - bedrock-agentcore:GetAgentRuntime
                  - bedrock-agentcore:GetAgentRuntimeEndpoint
                  - bedrock-agentcore:UpdateAgentRuntime
                  - bedrock-agentcore:UpdateAgentRuntimeEndpoint
                Resource: '*'
        - PolicyName: IAMPassRole
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - iam:PassRole
                Resource: !GetAtt AgentCoreRuntimeExecutionRole.Arn
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-ECR-Notification-Role'

  # Lambda Function for ECR Image Notification
  ECRImageNotificationFunction:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.13
      Handler: index.lambda_handler
      Role: !GetAtt ECRImageNotificationLambdaRole.Arn
      Timeout: 300
      Environment:
        Variables:
          AGENT_RUNTIME_ID: !GetAtt AgentRuntime.AgentRuntimeId
          ECR_REPOSITORY_URI: !Sub '${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${AgentECRRepository}'
          ROLE_ARN: !GetAtt AgentCoreRuntimeExecutionRole.Arn
      Code:
        ZipFile: |
          import json
          import logging
          import boto3
          import os

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
              try:
                  logger.info(f"Received ECR event: {json.dumps(event)}")

                  # Parse the ECR event
                  detail = event.get('detail', {})
                  repository_name = detail.get('repository-name')
                  image_tag = detail.get('image-tag', 'latest')
                  action = detail.get('action-type')
                  result = detail.get('result')

                  logger.info(f"ECR Event - Repository: {repository_name}, Tag: {image_tag}, Action: {action}, Result: {result}")

                  # Only proceed if the push was successful
                  if action != 'PUSH' or result != 'SUCCESS':
                      logger.info("Skipping non-push or failed event")
                      return {
                          'statusCode': 200,
                          'body': json.dumps('Event skipped - not a successful push')
                      }

                  # Get environment variables
                  agent_runtime_id = os.environ['AGENT_RUNTIME_ID']
                  ecr_repository_uri = os.environ['ECR_REPOSITORY_URI']
                  role_arn = os.environ['ROLE_ARN']

                  # Initialize bedrock-agentcore-control client
                  client = boto3.client('bedrock-agentcore-control')

                  # Get current runtime configuration
                  logger.info(f"Getting current runtime configuration for: {agent_runtime_id}")
                  get_response = client.get_agent_runtime(agentRuntimeId=agent_runtime_id)

                  logger.info(f"Current runtime status: {get_response}")

                  # Build new container URI with the pushed image tag
                  new_container_uri = f"{ecr_repository_uri}:{image_tag}"

                  logger.info(f"Updating runtime to use new container: {new_container_uri}")

                  # Update the runtime with the new container image
                  update_response = client.update_agent_runtime(
                      agentRuntimeId=agent_runtime_id,
                      agentRuntimeArtifact={
                          'containerConfiguration': {
                              'containerUri': new_container_uri
                          }
                      },
                      roleArn=role_arn,
                      networkConfiguration=get_response['networkConfiguration'],
                      protocolConfiguration=get_response['protocolConfiguration'],
                      authorizerConfiguration=get_response['authorizerConfiguration'],
                      environmentVariables=get_response['environmentVariables'],
                  )

                  logger.info(f"Runtime updated successfully. New version: {update_response['agentRuntimeVersion']}")

                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'message': 'AgentCore Runtime updated successfully',
                          'newContainerUri': new_container_uri,
                          'runtimeId': agent_runtime_id,
                          'newVersion': update_response['agentRuntimeVersion']
                      })
                  }

              except Exception as e:
                  logger.error(f"Error processing ECR event: {str(e)}", exc_info=True)
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': str(e)})
                  }
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-ECR-Notification-Function'

  # EventBridge Permission for Lambda
  ECRImageNotificationLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref ECRImageNotificationFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt ECRImageEventRule.Arn

  # EventBridge Rule for ECR Image Push
  ECRImageEventRule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub '${AWS::StackName}-agent-ecr-push-rule'
      Description: 'Trigger Lambda when new ECR image is pushed'
      EventPattern:
        source:
          - aws.ecr
        detail-type:
          - ECR Image Action
        detail:
          action-type:
            - PUSH
          result:
            - SUCCESS
          repository-name:
            - !Ref AgentECRRepository
      State: ENABLED
      Targets:
        - Arn: !GetAtt ECRImageNotificationFunction.Arn
          Id: ECRImageNotificationTarget

  # Lambda Execution Role for CodeBuild Trigger
  CodeBuildTriggerLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: CodeBuildTriggerPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - codebuild:StartBuild
                  - codebuild:BatchGetBuilds
                Resource: !GetAtt AgentDockerBuildProject.Arn
        - PolicyName: SecretsManagerAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                Resource:
                  Fn::ImportValue: !Sub '${CognitoStackName}-WebSearchClientSecretArn'
        - PolicyName: BedrockIdentityAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock-agentcore:GetResourceOauth2Token
                  - bedrock-agentcore:CreateOauth2CredentialProvider
                  - bedrock-agentcore:DeleteOauth2CredentialProvider
                  - bedrock-agentcore:UpdateOauth2CredentialProvider
                  - bedrock-agentcore:ListOauth2CredentialProviders
                  - bedrock-agentcore:GetOauth2CredentialProvider
                Resource: '*'
        - PolicyName: ECRCleanupPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ecr:ListImages
                  - ecr:BatchDeleteImage
                Resource: !GetAtt AgentECRRepository.Arn
              - Effect: Allow
                Action:
                  - secretsmanager:CreateSecret
                  - secretsmanager:DeleteSecret
                Resource: '*'
              - Effect: Allow
                Action:
                  - bedrock-agentcore:ListWorkloadIdentities
                  - bedrock-agentcore:UpdateWorkloadIdentity
                  - bedrock-agentcore:DeleteWorkloadIdentity
                  - bedrock-agentcore:CreateWorkloadIdentity
                Resource:
                  - !Sub 'arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:workload-identity-directory/*/workload-identity/*'
                  - !Sub 'arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:workload-identity-directory/*'
              - Effect: Allow
                Action:
                  - bedrock-agentcore:GetResourceOauth2Token
                  - bedrock-agentcore:CreateOauth2CredentialProvider
                  - bedrock-agentcore:DeleteOauth2CredentialProvider
                  - bedrock-agentcore:UpdateOauth2CredentialProvider
                  - bedrock-agentcore:ListOauth2CredentialProviders
                  - bedrock-agentcore:GetOauth2CredentialProvider
                Resource: '*'
              - Effect: Allow
                Action:
                  - bedrock-agentcore:GetTokenVault
                  - bedrock-agentcore:CreateTokenVault
                  - bedrock-agentcore:DeleteTokenVault
                Resource: '*'
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-CodeBuild-Trigger-Role'

  # Lambda Function to Trigger CodeBuild
  CodeBuildTriggerFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-agent-codebuild'
      Runtime: python3.13
      Handler: index.lambda_handler
      Role: !GetAtt CodeBuildTriggerLambdaRole.Arn
      Timeout: 900
      Environment:
        Variables:
          CODEBUILD_PROJECT_NAME: !Ref AgentDockerBuildProject
          AGENT_CLIENT_SECRET_ARN:
            Fn::ImportValue: !Sub '${CognitoStackName}-WebSearchClientSecretArn'
          DISCOVERY_URL:
            Fn::ImportValue: !Sub '${CognitoStackName}-DiscoveryUrl'
          ECR_REPOSITORY_NAME: !Ref AgentECRRepository
      Code:
        ZipFile: |
          import json
          import boto3
          import urllib3
          import logging
          import os
          import time

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def create_oauth2_credential_provider(secret_arn, discovery_url, provider_name):
              try:
                  logger.info(f"Creating OAuth2 credential provider for Agent: {provider_name}")

                  # Get client credentials from Secrets Manager
                  secrets_client = boto3.client('secretsmanager')
                  secret_response = secrets_client.get_secret_value(SecretId=secret_arn)
                  secret_data = json.loads(secret_response['SecretString'])

                  client_id = secret_data['client_id']
                  client_secret = secret_data['client_secret']
                  token_url = secret_data['token_endpoint']
                  auth_url = discovery_url.replace('/.well-known/openid-configuration', '/oauth2/authorize')

                  # Create OAuth2 credential provider
                  identity_client = boto3.client("bedrock-agentcore-control",)

                  identity_client.create_oauth2_credential_provider(
                      name=provider_name,
                      credentialProviderVendor="CustomOauth2",
                      oauth2ProviderConfigInput={
                          "customOauth2ProviderConfig": {
                              "clientId": client_id,
                              "clientSecret": client_secret,
                              "oauthDiscovery": {
                                "discoveryUrl": discovery_url
                              },
                          }
                      },
                  )

                  logger.info(f"OAuth2 credential provider created: {provider_name}")
                  return provider_name

              except Exception as e:
                  logger.error(f"Failed to create OAuth2 credential provider: {str(e)}")
                  raise e

          def empty_ecr_repository(repository_name):
              try:
                  logger.info(f"Emptying ECR repository: {repository_name}")

                  ecr_client = boto3.client('ecr')

                  # List all images in the repository
                  response = ecr_client.list_images(repositoryName=repository_name)

                  if not response['imageIds']:
                      logger.info("Repository is already empty")
                      return

                  # Delete all images
                  logger.info(f"Deleting {len(response['imageIds'])} images from repository")
                  ecr_client.batch_delete_image(
                      repositoryName=repository_name,
                      imageIds=response['imageIds']
                  )

                  logger.info(f"Successfully emptied ECR repository: {repository_name}")

              except Exception as e:
                  logger.error(f"Failed to empty ECR repository: {str(e)}")
                  # Don't raise the exception, as we want deletion to continue

          def lambda_handler(event, context):
              try:
                  logger.info(f"Received event: {json.dumps(event)}")

                  request_type = event['RequestType']
                  project_name = os.environ['CODEBUILD_PROJECT_NAME']
                  agent_client_secret_arn = os.environ['AGENT_CLIENT_SECRET_ARN']
                  discovery_url = os.environ['DISCOVERY_URL']
                  provider_name = event['ResourceProperties']['ProviderName']
                  ecr_repository_name = os.environ['ECR_REPOSITORY_NAME']

                  if request_type == 'Create':
                      # Create OAuth2 credential provider first
                      create_oauth2_credential_provider(agent_client_secret_arn, discovery_url, provider_name)
                      # Start CodeBuild project on stack creation and wait for completion
                      codebuild = boto3.client('codebuild')

                      logger.info(f"Starting CodeBuild project: {project_name}")

                      response = codebuild.start_build(projectName=project_name)
                      build_id = response['build']['id']

                      logger.info(f"Build started successfully with ID: {build_id}")

                      # Wait for build to complete
                      max_wait_time = 1800  # 30 minutes
                      wait_interval = 30    # 30 seconds
                      elapsed_time = 0

                      while elapsed_time < max_wait_time:
                          # Check remaining Lambda execution time
                          remaining_time = context.get_remaining_time_in_millis()
                          if remaining_time < 60000:  # Less than 1 minute left
                              logger.error("Lambda timeout approaching, cannot wait for build completion")
                              send_response(event, context, 'FAILED', {})
                              return

                          build_status = codebuild.batch_get_builds(ids=[build_id])
                          current_phase = build_status['builds'][0]['currentPhase']
                          build_complete = build_status['builds'][0]['buildComplete']

                          logger.info(f"Build status: {current_phase}, Complete: {build_complete}")

                          if build_complete:
                              final_status = build_status['builds'][0]['buildStatus']
                              logger.info(f"Build completed with status: {final_status}")

                              if final_status == 'SUCCEEDED':
                                  send_response(event, context, 'SUCCESS', {})
                                  return
                              else:
                                  send_response(event, context, 'FAILED', {})
                                  return

                          # Wait before checking again
                          time.sleep(wait_interval)
                          elapsed_time += wait_interval

                      # Timeout reached
                      send_response(event, context, 'FAILED', {})

                  elif request_type == 'Delete':
                      logger.info("Stack deletion - cleaning up resources")

                      # Clean up ECR repository
                      empty_ecr_repository(ecr_repository_name)

                      # Clean up OAuth2 credential provider
                      try:
                          identity_client = boto3.client("bedrock-agentcore-control",)
                          identity_client.delete_oauth2_credential_provider(name=provider_name)
                          logger.info(f"OAuth2 credential provider deleted: {provider_name}")
                      except Exception as e:
                          logger.error(f"Failed to delete OAuth2 credential provider: {str(e)}")
                          # Continue with deletion even if provider cleanup fails

                      send_response(event, context, 'SUCCESS', {})

                  elif request_type == 'Update':
                      logger.info("Stack update - no action required")
                      send_response(event, context, 'SUCCESS', {})

              except Exception as e:
                  logger.error(f"Error: {str(e)}")
                  send_response(event, context, 'FAILED', {})

          def send_response(event, context, response_status, response_data):
              response_body = {
                  'Status': response_status,
                  'Reason': 'See CloudWatch Logs',
                  'PhysicalResourceId': 'CodeBuildTrigger',
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  # 'Data': response_data
              }

              json_response_body = json.dumps(response_body)

              headers = {
                  'content-type': '',
                  'content-length': str(len(json_response_body))
              }

              http = urllib3.PoolManager()
              response = http.request('PUT', event['ResponseURL'], body=json_response_body, headers=headers)
              logger.info(f"Response status: {response.status}")

  # Custom Resource to Trigger CodeBuild on Stack Creation
  CodeBuildTrigger:
    Type: AWS::CloudFormation::CustomResource
    DependsOn: AgentDockerBuildProject
    Properties:
      ServiceToken: !GetAtt CodeBuildTriggerFunction.Arn
      ProviderName: !Sub 'AgentOAuth2Provider-${AWS::StackName}'

  # IAM Role for Memory Execution (required for Custom Memory Strategies)
  MemoryExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: bedrock-agentcore.amazonaws.com
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                'aws:SourceAccount': !Ref AWS::AccountId
              ArnLike:
                'aws:SourceArn': !Sub 'arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:*'
      Policies:
        - PolicyName: MemoryBedrockModelAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:InvokeModelWithResponseStream
                Resource:
                  - 'arn:aws:bedrock:*::foundation-model/*'
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-Memory-Execution-Role'

  AgentMemory:
    Type: AWS::BedrockAgentCore::Memory
    Properties:
      EventExpiryDuration: 60
      Name: !Join ['', !Split ['-', !Sub '${AWS::StackName}Memory']]
      MemoryExecutionRoleArn: !GetAtt MemoryExecutionRole.Arn
      MemoryStrategies:
        - CustomMemoryStrategy:
            Name: SearchQueryTracker
            Namespaces:
              - "/search-queries/{actorId}"
            Configuration:
              SemanticOverride:
                Extraction:
                  AppendToPrompt: |
                    Human: You are tasked with analyzing conversations to extract the user's preferences. You'll be analyzing two sets of data:

                    Follow some of the user preferences below as it pertains to memory related to web searches and AWS documentation queries:
                    <search_preferences>
                    1. Capture user preferences and recurring search patterns that the agent encounters.

                    2. Make sure to look out for the past conversation history for the user and keep that in consideration while interacting with the user.

                    3. Always be focused on web search and AWS documentation queries in terms of user preferences

                    4. Make sure to keep in mind the previous searches and solutions so if a similar query occurs, you can leverage past findings

                    5. Always extract the search queries, documentation sources, and key solutions provided.
                    </search_preferences>

                    <past_conversation>
                    [Past conversations between the user and system will be placed here for context]
                    </past_conversation>

                    <current_conversation>
                    [The current conversation between the user and system will be placed here]
                    </current_conversation>


                    Your job is to identify and categorize the user's preferences into two main types:
                    - Explicit preferences: Directly stated preferences by the user.
                    - Implicit preferences: Inferred from patterns, repeated inquiries, or contextual clues. Take a close look at user's request for implicit preferences.

                    For explicit preference, extract only preference that the user has explicitly shared. Do not infer user's preference.
                    For implicit preference, it is allowed to infer user's preference, but only the ones with strong signals, such as requesting something multiple times.
                    Assistant:
                  ModelId: "us.anthropic.claude-3-5-sonnet-20241022-v2:0"
        - SemanticMemoryStrategy: 
            Name: SemanticMemory
            Namespaces:
              - "/knowledge/{actorId}"
        - SummaryMemoryStrategy: 
            Name: SessionSummarizer
            Namespaces:
              - "/summaries/{actorId}/{sessionId}"
        - UserPreferenceMemoryStrategy: 
            Name: UserPreference
            Namespaces:
              - "/users/{actorId}"
      Tags: 
        Name: !Sub '${AWS::StackName}-Agent-Memory'


  # BedrockAgentCore Runtime using build-1 ECR image (first build from CodeBuildTrigger)
  AgentRuntime:
    Type: AWS::BedrockAgentCore::Runtime
    DependsOn: CodeBuildTrigger
    Properties:
      AgentRuntimeName: !Join ['', !Split ['-', !Sub '${AWS::StackName}']]
      RoleArn: !GetAtt AgentCoreRuntimeExecutionRole.Arn
      NetworkConfiguration:
        NetworkMode: "PUBLIC"
      AgentRuntimeArtifact:
        ContainerConfiguration:
          ContainerUri: !Sub '${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${AgentECRRepository}:build-1'
      ProtocolConfiguration: A2A
      AuthorizerConfiguration:
        CustomJWTAuthorizer:
          DiscoveryUrl:
            Fn::ImportValue: !Sub '${CognitoStackName}-DiscoveryUrl'
          AllowedClients:
            - Fn::ImportValue: !Sub '${CognitoStackName}-WebSearchClientId'
      EnvironmentVariables:
        MODEL_ID: !Ref OpenAIModelId
        MCP_REGION: !Sub '${AWS::Region}'
        TAVILY_API_KEY: !Ref TavilyAPIKey
        OPENAI_API_KEY: !Ref OpenAIKey
        MEMORY_ID: !GetAtt AgentMemory.MemoryId
      Tags:
        Name: !Sub '${AWS::StackName}-Agent-Runtime'

  # SSM Parameter for Agent Runtime ID
  AgentRuntimeIdParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: '/websearchagent/agentcore/runtime-id'
      Description: 'BedrockAgentCore Runtime ID'
      Type: String
      Value: !GetAtt AgentRuntime.AgentRuntimeId
      Tags:
        Name: !Sub '${AWS::StackName}-AgentRuntimeId-Parameter'

  # SSM Parameter for OAuth2 Provider Name
  AgentProviderNameParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: '/websearchagent/agentcore/provider-name'
      Description: 'OAuth2 Credential Provider Name'
      Type: String
      Value: !Sub 'AgentOAuth2Provider-${AWS::StackName}'
      Tags:
        Name: !Sub '${AWS::StackName}-ProviderName-Parameter'

Outputs:
  AgentRuntimeArn:
    Description: 'ARN of the BedrockAgentCore Runtime'
    Value: !GetAtt AgentRuntime.AgentRuntimeArn
    Export:
      Name: !Sub '${AWS::StackName}-AgentRuntimeArn'

  AgentRuntimeId:
    Description: 'ID of the BedrockAgentCore Runtime'
    Value: !GetAtt AgentRuntime.AgentRuntimeId
    Export:
      Name: !Sub '${AWS::StackName}-AgentRuntimeId'

  AgentRuntimeName:
    Description: 'Name of the BedrockAgentCore Runtime'
    Value: !Ref AgentRuntime
    Export:
      Name: !Sub '${AWS::StackName}-AgentRuntimeName'
  
  AgentProviderName: 
    Description: 'Name of the Agent provider'
    Value: !Sub 'AgentOAuth2Provider-${AWS::StackName}'
    Export:
      Name: !Sub '${AWS::StackName}-AgentProviderName'