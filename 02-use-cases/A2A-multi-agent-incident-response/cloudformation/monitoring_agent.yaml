AWSTemplateFormatVersion: '2010-09-09'
Description: "AgentCore Runtime"

Parameters:
  BedrockModelId:
    Type: String
    Description: Amazon Bedrock model id
    Default: 'global.anthropic.claude-sonnet-4-20250514-v1:0'

  GitHubURL:
    Type: String
    Description: Github URL of the project
    Default: https://github.com/awslabs/amazon-bedrock-agentcore-samples.git

  AgentDirectory:
    Type: String
    Description: Agent directory with Dockerfile of agent
    Default: monitoring_strands_agent

  CognitoStackName:
    Type: String
    Description: Name of the Cognito CloudFormation stack to import values from

  SmithyModelS3Bucket:
    Type: String
    Description: S3 bucket containing the Smithy model file

  SmithyModelS3Key:
    Type: String
    Description: S3 key (path) to the Smithy model file
    Default: 'smithy-models/monitoring-service.json'

Resources:
  
  AgentCoreRuntimeExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: AssumeRolePolicy
            Effect: Allow
            Principal:
              Service: bedrock-agentcore.amazonaws.com
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                'aws:SourceAccount': !Ref AWS::AccountId
              ArnLike:
                'aws:SourceArn': !Sub 'arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:*'
      Policies:
        - PolicyName: AgentCoreRuntimeExecutionPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Sid: ECRImageAccess
                Effect: Allow
                Action:
                  - ecr:BatchGetImage
                  - ecr:GetDownloadUrlForLayer
                Resource:
                  - !Sub 'arn:aws:ecr:${AWS::Region}:${AWS::AccountId}:repository/*'
              - Effect: Allow
                Action:
                  - logs:DescribeLogStreams
                  - logs:CreateLogGroup
                Resource:
                  - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/bedrock-agentcore/runtimes/*'
              - Effect: Allow
                Action:
                  - logs:DescribeLogGroups
                Resource:
                  - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:*'
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/bedrock-agentcore/runtimes/*:log-stream:*'
              - Sid: ECRTokenAccess
                Effect: Allow
                Action:
                  - ecr:GetAuthorizationToken
                Resource: '*'
              - Effect: Allow
                Action:
                  - xray:PutTraceSegments
                  - xray:PutTelemetryRecords
                  - xray:GetSamplingRules
                  - xray:GetSamplingTargets
                Resource: '*'
              - Effect: Allow
                Resource: '*'
                Action: cloudwatch:PutMetricData
                Condition:
                  StringEquals:
                    'cloudwatch:namespace': 'bedrock-agentcore'
              - Sid: BedrockModelAccess
                Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:InvokeModelWithResponseStream
                Resource:
                  - 'arn:aws:bedrock:*::foundation-model/*'
                  - !Sub 'arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:*'
              - Sid: SSMParameterAccess
                Effect: Allow
                Action:
                  - ssm:GetParameter
                  - ssm:GetParameters
                Resource:
                  - !Sub 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/*'
              - Sid: Oauth2Token
                Effect: Allow
                Action:
                  - bedrock-agentcore:GetResourceOauth2Token
                  # TODO: Scope down
                Resource:
                  - '*'
              - Sid: SecretsManager
                Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                  # TODO: Scope down
                Resource:
                  - '*'
              - Sid: MemoryAccess
                Effect: Allow
                Action:
                  - bedrock-agentcore:ListMemories
                  - bedrock-agentcore:ListMemoryRecords
                  - bedrock-agentcore:RetrieveMemoryRecords
                  - bedrock-agentcore:GetMemory
                  - bedrock-agentcore:GetMemoryRecord
                  - bedrock-agentcore:BatchCreateMemoryRecords
                  - bedrock-agentcore:BatchDeleteMemoryRecords
                  - bedrock-agentcore:BatchUpdateMemoryRecords
                  - bedrock-agentcore:ListActors
                  - bedrock-agentcore:ListEvents
                  - bedrock-agentcore:CreateEvent
                  - bedrock-agentcore:GetEvent
                Resource:
                  - !GetAtt AgentMemory.MemoryArn
                  - !Sub '${AgentMemory.MemoryArn}/*'
              - Sid: S3SmithyModelAccess
                Effect: Allow
                Action:
                  - s3:GetObject
                Resource:
                  - !Sub 'arn:aws:s3:::${SmithyModelS3Bucket}/${SmithyModelS3Key}'
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-Runtime-Role'

  # ECR Repository for Agent Docker Images
  AgentECRRepository:
    Type: AWS::ECR::Repository
    DeletionPolicy: Delete
    Properties:
      ImageScanningConfiguration:
        ScanOnPush: true
      LifecyclePolicy:
        LifecyclePolicyText: |
          {
            "rules": [
              {
                "rulePriority": 1,
                "description": "Keep last 10 images",
                "selection": {
                  "tagStatus": "any",
                  "countType": "imageCountMoreThan",
                  "countNumber": 10
                },
                "action": {
                  "type": "expire"
                }
              }
            ]
          }
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-Agent-ECR-Repository'

  # CodeBuild Service Role for Docker Image Build
  CodeBuildServiceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: codebuild.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: CodeBuildLogsPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - "*"
        - PolicyName: ECRAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ecr:BatchCheckLayerAvailability
                  - ecr:GetDownloadUrlForLayer
                  - ecr:BatchGetImage
                  - ecr:GetAuthorizationToken
                Resource: '*'
              - Effect: Allow
                Action:
                  - ecr:InitiateLayerUpload
                  - ecr:UploadLayerPart
                  - ecr:CompleteLayerUpload
                  - ecr:PutImage
                Resource: !GetAtt AgentECRRepository.Arn
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-CodeBuild-Role'

  # CodeBuild Project for Agent Docker Image
  AgentDockerBuildProject:
    Type: AWS::CodeBuild::Project
    Properties:
      Description: 'Build and push agent Docker image to ECR'
      ServiceRole: !GetAtt CodeBuildServiceRole.Arn
      Artifacts:
        Type: NO_ARTIFACTS
      Environment:
        Type: ARM_CONTAINER
        ComputeType: BUILD_GENERAL1_LARGE
        Image: aws/codebuild/amazonlinux2-aarch64-standard:3.0
        PrivilegedMode: true
        EnvironmentVariables:
          - Name: ECR_REPOSITORY_URI
            Value: !Sub '${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${AgentECRRepository}'
          - Name: ECR_REPOSITORY_NAME
            Value: !Ref AgentECRRepository
          - Name: AWS_DEFAULT_REGION
            Value: !Ref AWS::Region
          - Name: AWS_ACCOUNT_ID
            Value: !Ref AWS::AccountId
          - Name: AGENT_DIRECTORY
            Value: !Ref AgentDirectory
      Source:
        Type: GITHUB
        Location: !Ref GitHubURL
        GitCloneDepth: 1
        BuildSpec: |
          version: 0.2
          phases:
            pre_build:
              commands:
                - echo "Checking current directory and contents..."
                - pwd
                - ls -la
                - echo "Navigating to agent directory..."
                - cd 02-use-cases/A2A-multi-agent-incident-response/
                - cd ${AGENT_DIRECTORY}
                - echo "Contents of agent directory:"
                - ls -la
                - echo "Checking for Dockerfile..."
                - cat Dockerfile || echo "Dockerfile not found"
                - echo "Generating unique image tag..."
                - export IMAGE_TAG="build-${CODEBUILD_BUILD_NUMBER}"
                - echo "Image will be tagged as ${IMAGE_TAG}"
            build:
              commands:
                - echo "Starting parallel Docker build and ECR authentication..."
                - |
                  docker build -t bedrock-agentcore-arm64 . &
                  BUILD_PID=$!
                  aws ecr get-login-password --region $AWS_DEFAULT_REGION | \
                  docker login --username AWS --password-stdin $ECR_REPOSITORY_URI &
                  AUTH_PID=$!
                  echo "Waiting for Docker build to complete..."
                  wait $BUILD_PID
                  if [ $? -ne 0 ]; then
                    echo "Docker build failed"
                    exit 1
                  fi
                  echo "Waiting for ECR authentication to complete..."
                  wait $AUTH_PID
                  if [ $? -ne 0 ]; then
                    echo "ECR authentication failed"
                    exit 1
                  fi
                  echo "Both build and auth completed successfully"
                - echo "Tagging image with unique tag ${IMAGE_TAG}..."
                - docker tag bedrock-agentcore-arm64:latest $ECR_REPOSITORY_URI:${IMAGE_TAG}
            post_build:
              commands:
                - echo "Pushing ARM64 image to ECR with unique tag ${IMAGE_TAG}..."
                - docker push $ECR_REPOSITORY_URI:${IMAGE_TAG}
                - echo "Build completed at $(date)"
                - echo "Image tag pushed - ${IMAGE_TAG}"
      TimeoutInMinutes: 30
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-Agent-Docker-Build'

  # Lambda Execution Role for ECR Image Notification
  ECRImageNotificationLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: ECRAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ecr:DescribeImages
                  - ecr:ListImages
                Resource: !GetAtt AgentECRRepository.Arn
        - PolicyName: BedrockAgentCoreAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock-agentcore:ListAgentRuntimes
                  - bedrock-agentcore:ListAgentRuntimeEndpoints
                  - bedrock-agentcore:ListAgentRuntimeVersions
                  - bedrock-agentcore:GetAgentRuntime
                  - bedrock-agentcore:GetAgentRuntimeEndpoint
                  - bedrock-agentcore:UpdateAgentRuntime
                  - bedrock-agentcore:UpdateAgentRuntimeEndpoint
                Resource: '*'
        - PolicyName: IAMPassRole
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - iam:PassRole
                Resource: !GetAtt AgentCoreRuntimeExecutionRole.Arn
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-ECR-Notification-Role'

  # Lambda Function for ECR Image Notification
  ECRImageNotificationFunction:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.13
      Handler: index.lambda_handler
      Role: !GetAtt ECRImageNotificationLambdaRole.Arn
      Timeout: 300
      Environment:
        Variables:
          AGENT_RUNTIME_ID: !GetAtt AgentRuntime.AgentRuntimeId
          ECR_REPOSITORY_URI: !Sub '${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${AgentECRRepository}'
          ROLE_ARN: !GetAtt AgentCoreRuntimeExecutionRole.Arn
      Code:
        ZipFile: |
          import json
          import logging
          import boto3
          import os

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
              try:
                  logger.info(f"Received ECR event: {json.dumps(event)}")

                  # Parse the ECR event
                  detail = event.get('detail', {})
                  repository_name = detail.get('repository-name')
                  image_tag = detail.get('image-tag', 'latest')
                  action = detail.get('action-type')
                  result = detail.get('result')

                  logger.info(f"ECR Event - Repository: {repository_name}, Tag: {image_tag}, Action: {action}, Result: {result}")

                  # Only proceed if the push was successful
                  if action != 'PUSH' or result != 'SUCCESS':
                      logger.info("Skipping non-push or failed event")
                      return {
                          'statusCode': 200,
                          'body': json.dumps('Event skipped - not a successful push')
                      }

                  # Get environment variables
                  agent_runtime_id = os.environ['AGENT_RUNTIME_ID']
                  ecr_repository_uri = os.environ['ECR_REPOSITORY_URI']
                  role_arn = os.environ['ROLE_ARN']

                  # Initialize bedrock-agentcore-control client
                  client = boto3.client('bedrock-agentcore-control')

                  # Get current runtime configuration
                  logger.info(f"Getting current runtime configuration for: {agent_runtime_id}")
                  get_response = client.get_agent_runtime(agentRuntimeId=agent_runtime_id)

                  logger.info(f"Current runtime status: {get_response}")

                  # Build new container URI with the pushed image tag
                  new_container_uri = f"{ecr_repository_uri}:{image_tag}"

                  logger.info(f"Updating runtime to use new container: {new_container_uri}")

                  # Update the runtime with the new container image
                  update_response = client.update_agent_runtime(
                      agentRuntimeId=agent_runtime_id,
                      agentRuntimeArtifact={
                          'containerConfiguration': {
                              'containerUri': new_container_uri
                          }
                      },
                      roleArn=role_arn,
                      networkConfiguration=get_response['networkConfiguration'],
                      protocolConfiguration=get_response['protocolConfiguration'],
                      authorizerConfiguration=get_response['authorizerConfiguration'],
                      environmentVariables=get_response['environmentVariables'],
                  )

                  logger.info(f"Runtime updated successfully. New version: {update_response['agentRuntimeVersion']}")

                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'message': 'AgentCore Runtime updated successfully',
                          'newContainerUri': new_container_uri,
                          'runtimeId': agent_runtime_id,
                          'newVersion': update_response['agentRuntimeVersion']
                      })
                  }

              except Exception as e:
                  logger.error(f"Error processing ECR event: {str(e)}", exc_info=True)
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': str(e)})
                  }
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-ECR-Notification-Function'

  # EventBridge Permission for Lambda
  ECRImageNotificationLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref ECRImageNotificationFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt ECRImageEventRule.Arn

  # EventBridge Rule for ECR Image Push
  ECRImageEventRule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub '${AWS::StackName}-agent-ecr-push-rule'
      Description: 'Trigger Lambda when new ECR image is pushed'
      EventPattern:
        source:
          - aws.ecr
        detail-type:
          - ECR Image Action
        detail:
          action-type:
            - PUSH
          result:
            - SUCCESS
          repository-name:
            - !Ref AgentECRRepository
      State: ENABLED
      Targets:
        - Arn: !GetAtt ECRImageNotificationFunction.Arn
          Id: ECRImageNotificationTarget

  # Lambda Execution Role for CodeBuild Trigger
  CodeBuildTriggerLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: CodeBuildTriggerPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - codebuild:StartBuild
                  - codebuild:BatchGetBuilds
                Resource: !GetAtt AgentDockerBuildProject.Arn
        - PolicyName: SecretsManagerAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                Resource:
                  Fn::ImportValue: !Sub '${CognitoStackName}-MonitoringClientSecretArn'
        - PolicyName: BedrockIdentityAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock-agentcore:GetResourceOauth2Token
                  - bedrock-agentcore:CreateOauth2CredentialProvider
                  - bedrock-agentcore:DeleteOauth2CredentialProvider
                  - bedrock-agentcore:UpdateOauth2CredentialProvider
                  - bedrock-agentcore:ListOauth2CredentialProviders
                  - bedrock-agentcore:GetOauth2CredentialProvider
                Resource: '*'
        - PolicyName: ECRCleanupPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ecr:ListImages
                  - ecr:BatchDeleteImage
                Resource: !GetAtt AgentECRRepository.Arn
              - Effect: Allow
                Action:
                  - secretsmanager:CreateSecret
                  - secretsmanager:DeleteSecret
                Resource: '*'
              - Effect: Allow
                Action:
                  - bedrock-agentcore:ListWorkloadIdentities
                  - bedrock-agentcore:UpdateWorkloadIdentity
                  - bedrock-agentcore:DeleteWorkloadIdentity
                  - bedrock-agentcore:CreateWorkloadIdentity
                Resource:
                  - !Sub 'arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:workload-identity-directory/*/workload-identity/*'
                  - !Sub 'arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:workload-identity-directory/*'
              - Effect: Allow
                Action:
                  - bedrock-agentcore:GetResourceOauth2Token
                  - bedrock-agentcore:CreateOauth2CredentialProvider
                  - bedrock-agentcore:DeleteOauth2CredentialProvider
                  - bedrock-agentcore:UpdateOauth2CredentialProvider
                  - bedrock-agentcore:ListOauth2CredentialProviders
                  - bedrock-agentcore:GetOauth2CredentialProvider
                Resource: '*'
              - Effect: Allow
                Action:
                  - bedrock-agentcore:GetTokenVault
                  - bedrock-agentcore:CreateTokenVault
                  - bedrock-agentcore:DeleteTokenVault
                Resource: '*'
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-CodeBuild-Trigger-Role'

  # Lambda Function to Trigger CodeBuild
  CodeBuildTriggerFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-agent-codebuild'
      Runtime: python3.13
      Handler: index.lambda_handler
      Role: !GetAtt CodeBuildTriggerLambdaRole.Arn
      Timeout: 900
      Environment:
        Variables:
          CODEBUILD_PROJECT_NAME: !Ref AgentDockerBuildProject
          AGENT_CLIENT_SECRET_ARN:
            Fn::ImportValue: !Sub '${CognitoStackName}-MonitoringClientSecretArn'
          DISCOVERY_URL:
            Fn::ImportValue: !Sub '${CognitoStackName}-DiscoveryUrl'
          ECR_REPOSITORY_NAME: !Ref AgentECRRepository
      Code:
        ZipFile: |
          import json
          import boto3
          import urllib3
          import logging
          import os
          import time

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def create_oauth2_credential_provider(secret_arn, discovery_url, provider_name):
              try:
                  logger.info(f"Creating OAuth2 credential provider for Agent: {provider_name}")

                  # Get client credentials from Secrets Manager
                  secrets_client = boto3.client('secretsmanager')
                  secret_response = secrets_client.get_secret_value(SecretId=secret_arn)
                  secret_data = json.loads(secret_response['SecretString'])

                  client_id = secret_data['client_id']
                  client_secret = secret_data['client_secret']
                  token_url = secret_data['token_endpoint']
                  auth_url = discovery_url.replace('/.well-known/openid-configuration', '/oauth2/authorize')

                  # Create OAuth2 credential provider
                  identity_client = boto3.client("bedrock-agentcore-control",)

                  identity_client.create_oauth2_credential_provider(
                      name=provider_name,
                      credentialProviderVendor="CustomOauth2",
                      oauth2ProviderConfigInput={
                          "customOauth2ProviderConfig": {
                              "clientId": client_id,
                              "clientSecret": client_secret,
                              "oauthDiscovery": {
                                "discoveryUrl": discovery_url
                              },
                          }
                      },
                  )

                  logger.info(f"OAuth2 credential provider created: {provider_name}")
                  return provider_name

              except Exception as e:
                  logger.error(f"Failed to create OAuth2 credential provider: {str(e)}")
                  raise e

          def empty_ecr_repository(repository_name):
              try:
                  logger.info(f"Emptying ECR repository: {repository_name}")

                  ecr_client = boto3.client('ecr')

                  # List all images in the repository
                  response = ecr_client.list_images(repositoryName=repository_name)

                  if not response['imageIds']:
                      logger.info("Repository is already empty")
                      return

                  # Delete all images
                  logger.info(f"Deleting {len(response['imageIds'])} images from repository")
                  ecr_client.batch_delete_image(
                      repositoryName=repository_name,
                      imageIds=response['imageIds']
                  )

                  logger.info(f"Successfully emptied ECR repository: {repository_name}")

              except Exception as e:
                  logger.error(f"Failed to empty ECR repository: {str(e)}")
                  # Don't raise the exception, as we want deletion to continue

          def lambda_handler(event, context):
              try:
                  logger.info(f"Received event: {json.dumps(event)}")

                  request_type = event['RequestType']
                  project_name = os.environ['CODEBUILD_PROJECT_NAME']
                  agent_client_secret_arn = os.environ['AGENT_CLIENT_SECRET_ARN']
                  discovery_url = os.environ['DISCOVERY_URL']
                  provider_name = event['ResourceProperties']['ProviderName']
                  ecr_repository_name = os.environ['ECR_REPOSITORY_NAME']

                  if request_type == 'Create':
                      # Create OAuth2 credential provider first
                      create_oauth2_credential_provider(agent_client_secret_arn, discovery_url, provider_name)
                      # Start CodeBuild project on stack creation and wait for completion
                      codebuild = boto3.client('codebuild')

                      logger.info(f"Starting CodeBuild project: {project_name}")

                      response = codebuild.start_build(projectName=project_name)
                      build_id = response['build']['id']

                      logger.info(f"Build started successfully with ID: {build_id}")

                      # Wait for build to complete
                      max_wait_time = 1800  # 30 minutes
                      wait_interval = 30    # 30 seconds
                      elapsed_time = 0

                      while elapsed_time < max_wait_time:
                          # Check remaining Lambda execution time
                          remaining_time = context.get_remaining_time_in_millis()
                          if remaining_time < 60000:  # Less than 1 minute left
                              logger.error("Lambda timeout approaching, cannot wait for build completion")
                              send_response(event, context, 'FAILED', {})
                              return

                          build_status = codebuild.batch_get_builds(ids=[build_id])
                          current_phase = build_status['builds'][0]['currentPhase']
                          build_complete = build_status['builds'][0]['buildComplete']

                          logger.info(f"Build status: {current_phase}, Complete: {build_complete}")

                          if build_complete:
                              final_status = build_status['builds'][0]['buildStatus']
                              logger.info(f"Build completed with status: {final_status}")

                              if final_status == 'SUCCEEDED':
                                  send_response(event, context, 'SUCCESS', {})
                                  return
                              else:
                                  send_response(event, context, 'FAILED', {})
                                  return

                          # Wait before checking again
                          time.sleep(wait_interval)
                          elapsed_time += wait_interval

                      # Timeout reached
                      send_response(event, context, 'FAILED', {})

                  elif request_type == 'Delete':
                      logger.info("Stack deletion - cleaning up resources")

                      # Clean up ECR repository
                      empty_ecr_repository(ecr_repository_name)

                      # Clean up OAuth2 credential provider
                      try:
                          identity_client = boto3.client("bedrock-agentcore-control",)
                          identity_client.delete_oauth2_credential_provider(name=provider_name)
                          logger.info(f"OAuth2 credential provider deleted: {provider_name}")
                      except Exception as e:
                          logger.error(f"Failed to delete OAuth2 credential provider: {str(e)}")
                          # Continue with deletion even if provider cleanup fails

                      send_response(event, context, 'SUCCESS', {})

                  elif request_type == 'Update':
                      logger.info("Stack update - no action required")
                      send_response(event, context, 'SUCCESS', {})

              except Exception as e:
                  logger.error(f"Error: {str(e)}")
                  send_response(event, context, 'FAILED', {})

          def send_response(event, context, response_status, response_data):
              response_body = {
                  'Status': response_status,
                  'Reason': 'See CloudWatch Logs',
                  'PhysicalResourceId': 'CodeBuildTrigger',
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  # 'Data': response_data
              }

              json_response_body = json.dumps(response_body)

              headers = {
                  'content-type': '',
                  'content-length': str(len(json_response_body))
              }

              http = urllib3.PoolManager()
              response = http.request('PUT', event['ResponseURL'], body=json_response_body, headers=headers)
              logger.info(f"Response status: {response.status}")

  # Custom Resource to Trigger CodeBuild on Stack Creation
  CodeBuildTrigger:
    Type: AWS::CloudFormation::CustomResource
    DependsOn: AgentDockerBuildProject
    Properties:
      ServiceToken: !GetAtt CodeBuildTriggerFunction.Arn
      ProviderName: !Sub 'AgentOAuth2Provider-${AWS::StackName}'

  # IAM Role for Memory Execution (required for Custom Memory Strategies)
  MemoryExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: bedrock-agentcore.amazonaws.com
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                'aws:SourceAccount': !Ref AWS::AccountId
              ArnLike:
                'aws:SourceArn': !Sub 'arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:*'
      Policies:
        - PolicyName: MemoryBedrockModelAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:InvokeModelWithResponseStream
                Resource:
                  - 'arn:aws:bedrock:*::foundation-model/*'
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-Memory-Execution-Role'

  AgentMemory:
    Type: AWS::BedrockAgentCore::Memory
    Properties:
      EventExpiryDuration: 60
      Name: !Join ['', !Split ['-', !Sub '${AWS::StackName}Memory']]
      MemoryExecutionRoleArn: !GetAtt MemoryExecutionRole.Arn
      MemoryStrategies: 
        - CustomMemoryStrategy: 
            Name: MonitoringIssueTracker
            Namespaces:
              - "/technical-issues/{actorId}"
            Configuration:
              SemanticOverride:
                Extraction:
                  AppendToPrompt: |
                    Human: You are a specialized memory extraction agent for an AWS monitoring AI. Your task is to identify and extract:

                    1. AWS service alerts and incidents mentioned by the user
                    2. CloudWatch metrics, alarms, and thresholds discussed
                    3. Resource identifiers (ARNs, IDs) and their associated metrics
                    4. Performance anomalies and their timestamps
                    5. Infrastructure configurations and scaling events
                    6. Previous remediation actions taken by the user

                    Only extract information that is explicitly stated by the user. Do not infer or guess information.
                    Focus on extracting factual, operational details that would be useful for future monitoring sessions.
                    Ignore casual conversation, greetings, or non-monitoring related information.

                    Pay special attention to:
                    - Metric values with their units and timestamps
                    - Alarm thresholds and their current states
                    - Service health indicators and status changes
                    - Resource utilization patterns and trends
                    - Log patterns and error frequencies

                    IMPORTANT: For whatever information that might be helpful in downstream processes with monitoring metrics, please extract that.

                    Format each extracted fact as a clear, concise statement that could stand alone as a reference point in a monitoring dashboard.
                    Assistant:
                  ModelId: "us.anthropic.claude-3-5-sonnet-20241022-v2:0"
                Consolidation:
                  AppendToPrompt: |
                    Human: You are a monitoring knowledge manager responsible for maintaining a coherent database of AWS infrastructure and application metrics.

                    When consolidating monitoring memories:
                    - Prioritize specific metric values, timestamps, and exact resource identifiers
                    - Preserve the chronological sequence of events for incident timelines
                    - Maintain the relationship between alarms, metrics, and the resources they monitor
                    - Keep distinct separation between different AWS accounts, regions, and environments
                    - Preserve exact error messages and log patterns without paraphrasing
                    - Update metric values while maintaining historical context and trends
                    - Merge related incidents while preserving the complete timeline of events
                    - Maintain clear connections between alerts and their corresponding remediation actions

                    For monitoring contexts, it's critical to maintain precision in timestamps, metric values, and resource relationships.
                    When updating existing memories with new information:
                    - Append new metric data points while preserving historical values
                    - Update status information while noting the time of status change
                    - Add new observations to existing incident records when they relate to the same root cause
                    - Create separate memories for distinct incidents even if they affect the same resource

                    The monitoring knowledge base must maintain both precision and temporal context to support effective incident analysis and pattern recognition.
                    Assistant:
                  ModelId: "us.anthropic.claude-3-5-sonnet-20241022-v2:0"
        - SemanticMemoryStrategy: 
            Name: SemanticMemory
            Namespaces:
              - "/knowledge/{actorId}"
        - UserPreferenceMemoryStrategy: 
            Name: UserPreference
            Namespaces:
              - "/users/{actorId}"
      Tags: 
        Name: !Sub '${AWS::StackName}-Agent-Memory'


  # BedrockAgentCore Runtime using build-1 ECR image (first build from CodeBuildTrigger)
  AgentRuntime:
    Type: AWS::BedrockAgentCore::Runtime
    DependsOn: CodeBuildTrigger
    Properties:
      AgentRuntimeName: !Join ['', !Split ['-', !Sub '${AWS::StackName}']]
      RoleArn: !GetAtt AgentCoreRuntimeExecutionRole.Arn
      NetworkConfiguration:
        NetworkMode: "PUBLIC"
      AgentRuntimeArtifact:
        ContainerConfiguration:
          ContainerUri: !Sub '${AWS::AccountId}.dkr.ecr.${AWS::Region}.amazonaws.com/${AgentECRRepository}:build-1'
      ProtocolConfiguration: A2A
      AuthorizerConfiguration:
        CustomJWTAuthorizer:
          DiscoveryUrl:
            Fn::ImportValue: !Sub '${CognitoStackName}-DiscoveryUrl'
          AllowedClients:
            - Fn::ImportValue: !Sub '${CognitoStackName}-MonitoringClientId'
      EnvironmentVariables:
        MODEL_ID: !Ref BedrockModelId
        MCP_REGION: !Sub '${AWS::Region}'
        MEMORY_ID: !GetAtt AgentMemory.MemoryId
        GATEWAY_PROVIDER_NAME: !Sub 'GatewayOAuth2Provider-${AWS::StackName}'
      Tags:
        Name: !Sub '${AWS::StackName}-Agent-Runtime'

  # SSM Parameter for Agent Runtime ID
  AgentRuntimeIdParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: '/monitoragent/agentcore/runtime-id'
      Description: 'BedrockAgentCore Runtime ID'
      Type: String
      Value: !GetAtt AgentRuntime.AgentRuntimeId
      Tags:
        Name: !Sub '${AWS::StackName}-AgentRuntimeId-Parameter'

  # SSM Parameter for OAuth2 Provider Name
  AgentProviderNameParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: '/monitoragent/agentcore/provider-name'
      Description: 'OAuth2 Credential Provider Name'
      Type: String
      Value: !Sub 'AgentOAuth2Provider-${AWS::StackName}'
      Tags:
        Name: !Sub '${AWS::StackName}-ProviderName-Parameter'


  # Lambda Execution Role for Gateway OAuth2 Setup
  GatewayOAuth2SetupLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: SecretsManagerAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                Resource:
                  Fn::ImportValue: !Sub '${CognitoStackName}-GatewayClientSecretArn'
        - PolicyName: BedrockIdentityAccessPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock-agentcore:GetResourceOauth2Token
                  - bedrock-agentcore:CreateOauth2CredentialProvider
                  - bedrock-agentcore:DeleteOauth2CredentialProvider
                  - bedrock-agentcore:UpdateOauth2CredentialProvider
                  - bedrock-agentcore:ListOauth2CredentialProviders
                  - bedrock-agentcore:GetOauth2CredentialProvider
                Resource: '*'
              - Effect: Allow
                Action:
                  - secretsmanager:CreateSecret
                  - secretsmanager:DeleteSecret
                Resource: '*'
              - Effect: Allow
                Action:
                  - bedrock-agentcore:ListWorkloadIdentities
                  - bedrock-agentcore:UpdateWorkloadIdentity
                  - bedrock-agentcore:DeleteWorkloadIdentity
                  - bedrock-agentcore:CreateWorkloadIdentity
                Resource:
                  - !Sub 'arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:workload-identity-directory/*/workload-identity/*'
                  - !Sub 'arn:aws:bedrock-agentcore:${AWS::Region}:${AWS::AccountId}:workload-identity-directory/*'
              - Effect: Allow
                Action:
                  - bedrock-agentcore:GetTokenVault
                  - bedrock-agentcore:CreateTokenVault
                  - bedrock-agentcore:DeleteTokenVault
                Resource: '*'
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-GatewayOAuth2Setup-Role'

  # Lambda Function for Gateway OAuth2 Credential Provider Setup
  GatewayOAuth2SetupFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-gateway-oauth2-setup'
      Runtime: python3.13
      Handler: index.lambda_handler
      Role: !GetAtt GatewayOAuth2SetupLambdaRole.Arn
      Timeout: 300
      Environment:
        Variables:
          GATEWAY_CLIENT_SECRET_ARN:
            Fn::ImportValue: !Sub '${CognitoStackName}-GatewayClientSecretArn'
          DISCOVERY_URL:
            Fn::ImportValue: !Sub '${CognitoStackName}-DiscoveryUrl'
      Code:
        ZipFile: |
          import json
          import boto3
          import urllib3
          import logging
          import os

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def create_oauth2_credential_provider(secret_arn, discovery_url, provider_name):
              try:
                  logger.info(f"Creating OAuth2 credential provider for Gateway: {provider_name}")

                  # Get client credentials from Secrets Manager
                  secrets_client = boto3.client('secretsmanager')
                  secret_response = secrets_client.get_secret_value(SecretId=secret_arn)
                  secret_data = json.loads(secret_response['SecretString'])

                  client_id = secret_data['client_id']
                  client_secret = secret_data['client_secret']

                  # Create OAuth2 credential provider
                  identity_client = boto3.client("bedrock-agentcore-control")

                  identity_client.create_oauth2_credential_provider(
                      name=provider_name,
                      credentialProviderVendor="CustomOauth2",
                      oauth2ProviderConfigInput={
                          "customOauth2ProviderConfig": {
                              "clientId": client_id,
                              "clientSecret": client_secret,
                              "oauthDiscovery": {
                                "discoveryUrl": discovery_url
                              },
                          }
                      },
                  )

                  logger.info(f"OAuth2 credential provider created: {provider_name}")
                  return provider_name

              except Exception as e:
                  logger.error(f"Failed to create OAuth2 credential provider: {str(e)}")
                  raise e

          def lambda_handler(event, context):
              try:
                  logger.info(f"Received event: {json.dumps(event)}")

                  request_type = event['RequestType']
                  gateway_client_secret_arn = os.environ['GATEWAY_CLIENT_SECRET_ARN']
                  discovery_url = os.environ['DISCOVERY_URL']
                  provider_name = event['ResourceProperties']['ProviderName']

                  if request_type == 'Create':
                      create_oauth2_credential_provider(gateway_client_secret_arn, discovery_url, provider_name)
                      send_response(event, context, 'SUCCESS', {})

                  elif request_type == 'Delete':
                      logger.info("Stack deletion - cleaning up OAuth2 credential provider")
                      try:
                          identity_client = boto3.client("bedrock-agentcore-control")
                          identity_client.delete_oauth2_credential_provider(name=provider_name)
                          logger.info(f"OAuth2 credential provider deleted: {provider_name}")
                      except Exception as e:
                          logger.error(f"Failed to delete OAuth2 credential provider: {str(e)}")
                      send_response(event, context, 'SUCCESS', {})

                  elif request_type == 'Update':
                      logger.info("Stack update - no action required")
                      send_response(event, context, 'SUCCESS', {})

              except Exception as e:
                  logger.error(f"Error: {str(e)}")
                  send_response(event, context, 'FAILED', {})

          def send_response(event, context, response_status, response_data):
              response_body = {
                  'Status': response_status,
                  'Reason': 'See CloudWatch Logs',
                  'PhysicalResourceId': 'GatewayOAuth2Setup',
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
              }

              json_response_body = json.dumps(response_body)

              headers = {
                  'content-type': '',
                  'content-length': str(len(json_response_body))
              }

              http = urllib3.PoolManager()
              response = http.request('PUT', event['ResponseURL'], body=json_response_body, headers=headers)
              logger.info(f"Response status: {response.status}")
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-GatewayOAuth2Setup-Function'

  # Custom Resource to Setup Gateway OAuth2 Credential Provider
  GatewayOAuth2Setup:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !GetAtt GatewayOAuth2SetupFunction.Arn
      ProviderName: !Sub 'GatewayOAuth2Provider-${AWS::StackName}'

  GatewayAgentCoreRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - bedrock-agentcore.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: BedrockAgentPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid: CloudWatchAccess
                Effect: Allow
                Action:
                  - cloudwatch:DescribeAlarms
                  - cloudwatch:GetMetricStatistics
                  - cloudwatch:ListDashboards
                  - cloudwatch:GetDashboard
                  - cloudwatch:ListMetrics
                  - cloudwatch:DescribeAlarmHistory
                  - logs:DescribeLogGroups
                  - logs:DescribeLogStreams
                  - logs:FilterLogEvents
                  - logs:GetLogEvents
                Resource: '*'

  # BedrockAgentCore Gateway
  MonitoringGateway:
    Type: AWS::BedrockAgentCore::Gateway
    DependsOn: GatewayOAuth2Setup
    Properties:
      Name: !Join ['', !Split ['-', !Sub '${AWS::StackName}Gateway']]
      Description: "Monitoring Gateway"
      AuthorizerConfiguration:
        CustomJWTAuthorizer:
          DiscoveryUrl:
            Fn::ImportValue: !Sub '${CognitoStackName}-DiscoveryUrl'
          AllowedClients:
            - Fn::ImportValue: !Sub '${CognitoStackName}-GatewayClientId'
      AuthorizerType: "CUSTOM_JWT"
      ProtocolConfiguration:
        Mcp:
          SearchType: "SEMANTIC"
      ProtocolType: "MCP"
      RoleArn: !GetAtt GatewayAgentCoreRole.Arn
      Tags:
        Name: !Sub '${AWS::StackName}-Monitoring-Gateway'

  # BedrockAgentCore Gateway Target (SmithyModel)
  MonitoringGatewayTarget:
    Type: AWS::BedrockAgentCore::GatewayTarget
    Properties:
      CredentialProviderConfigurations:
        - CredentialProviderType: GATEWAY_IAM_ROLE
      Description: "Monitoring Smithy Model Target"
      GatewayIdentifier: !GetAtt MonitoringGateway.GatewayIdentifier
      Name: !Join ['', !Split ['-', !Sub '${AWS::StackName}Target']]
      TargetConfiguration:
        Mcp:
          SmithyModel:
            S3:
              Uri: !Sub 's3://${SmithyModelS3Bucket}/${SmithyModelS3Key}'

  GatewayUrlParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: '/monitoragent/agentcore/gateway/gateway_url'
      Description: 'BedrockAgentCore Gateway URL'
      Type: String
      Value: !GetAtt MonitoringGateway.GatewayUrl
      Tags:
        Name: !Sub '${AWS::StackName}-GatewayURL'

Outputs:
  AgentRuntimeArn:
    Description: 'ARN of the BedrockAgentCore Runtime'
    Value: !GetAtt AgentRuntime.AgentRuntimeArn
    Export:
      Name: !Sub '${AWS::StackName}-AgentRuntimeArn'

  AgentRuntimeId:
    Description: 'ID of the BedrockAgentCore Runtime'
    Value: !GetAtt AgentRuntime.AgentRuntimeId
    Export:
      Name: !Sub '${AWS::StackName}-AgentRuntimeId'

  AgentRuntimeName:
    Description: 'Name of the BedrockAgentCore Runtime'
    Value: !Ref AgentRuntime
    Export:
      Name: !Sub '${AWS::StackName}-AgentRuntimeName'
  
  AgentProviderName:
    Description: 'Name of the Agent provider'
    Value: !Sub 'AgentOAuth2Provider-${AWS::StackName}'
    Export:
      Name: !Sub '${AWS::StackName}-AgentProviderName'

  MonitoringGatewayId:
    Description: 'ID of the Monitoring Gateway'
    Value: !GetAtt MonitoringGateway.GatewayIdentifier
    Export:
      Name: !Sub '${AWS::StackName}-MonitoringGatewayId'

  MonitoringGatewayArn:
    Description: 'ARN of the Monitoring Gateway'
    Value: !GetAtt MonitoringGateway.GatewayArn
    Export:
      Name: !Sub '${AWS::StackName}-MonitoringGatewayArn'

  MonitoringGatewayTargetId:
    Description: 'ID of the Monitoring Gateway Target'
    Value: !GetAtt MonitoringGatewayTarget.TargetId
    Export:
      Name: !Sub '${AWS::StackName}-MonitoringGatewayTargetId'

  GatewayProviderName:
    Description: 'Name of the Gateway OAuth2 Provider'
    Value: !Sub 'GatewayOAuth2Provider-${AWS::StackName}'
    Export:
      Name: !Sub '${AWS::StackName}-GatewayProviderName'